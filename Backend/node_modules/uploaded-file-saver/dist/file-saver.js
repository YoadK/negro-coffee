"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fileSaver = void 0;
const fs_1 = __importDefault(require("fs"));
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const uuid_1 = require("uuid");
class FileSaver {
    constructor() {
        this.containingFolder = path_1.default.join(__dirname, "..", "..", "..", "assets", "files");
    }
    config(containingFolder) {
        if (!containingFolder)
            throw new Error("containingFolder can't be empty.");
        if (!fs_1.default.existsSync(containingFolder))
            fs_1.default.mkdirSync(containingFolder, { recursive: true });
        this.containingFolder = containingFolder;
    }
    add(newUploadedFile, containingFolder) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!newUploadedFile)
                throw new Error("newUploadedFile can't be empty.");
            if (!containingFolder)
                containingFolder = this.containingFolder;
            if (!fs_1.default.existsSync(containingFolder))
                fs_1.default.mkdirSync(containingFolder, { recursive: true });
            const lastDotIndex = newUploadedFile.name.lastIndexOf(".");
            const extension = lastDotIndex === -1 ? "" : newUploadedFile.name.substring(lastDotIndex);
            const fileName = (0, uuid_1.v4)() + extension;
            const absolutePath = path_1.default.join(containingFolder, fileName);
            yield newUploadedFile.mv(absolutePath);
            return fileName;
        });
    }
    update(oldFileName, newUploadedFile, containingFolder) {
        return __awaiter(this, void 0, void 0, function* () {
            const newFileName = yield this.add(newUploadedFile, containingFolder);
            yield this.delete(oldFileName, containingFolder);
            return newFileName;
        });
    }
    delete(oldFileName, containingFolder) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!oldFileName)
                return;
            if (!this.containingFolder && !containingFolder)
                throw new Error("Must configure containing folder or sent one as an argument.");
            if (!containingFolder)
                containingFolder = this.containingFolder;
            const oldFilePath = path_1.default.join(containingFolder, oldFileName);
            if (!fs_1.default.existsSync(oldFilePath))
                return;
            for (let i = 1; i <= 10; i++) {
                try {
                    yield promises_1.default.rm(oldFilePath);
                    return;
                }
                catch (err) {
                    this.delay(50);
                }
            }
            throw new Error(`Failed to delete ${oldFilePath}.`);
        });
    }
    getFilePath(fileName, returnFileNotFoundPathIfFileNotExist = true, containingFolder) {
        if (!containingFolder)
            containingFolder = this.containingFolder;
        let filePath = path_1.default.join(containingFolder, fileName);
        if (returnFileNotFoundPathIfFileNotExist && !fs_1.default.existsSync(filePath))
            filePath = this.getFileNotFoundPath();
        return filePath;
    }
    getFileNotFoundPath() {
        return path_1.default.join(__dirname, "file-not-found.jpg");
    }
    delay(ms) {
        return new Promise(resolve => {
            setTimeout(() => resolve(), ms);
        });
    }
}
exports.fileSaver = new FileSaver();
